---
title: Deep Dive 19. 프로토타입
author: BeAPro
date: 2024-06-27 23:00:00 +0900
categories: [Deep Dive JS]
tags: [JavaScript]
image:
  path: /assets/img/title-image/deepdive.png
  alt: deepdive
---
## **상속과 프로토타입**
```js
// 생성자 함수
function Circle(radius){
  this.radius = radius;
  this.getArea = function(){
    return Math.PI * this.radius ** 2;
  }
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);
```
생성자 함수는 동일한 프로퍼티(메서드 포함) 구조를 갖는 객체를 여러 개 생성할 때 유용하다.
Circle 생성자 함수가 생성하는 모든 객체(인스턴스)는 radius프로퍼티와 getArea 프로퍼티를 갖는다.
getArea 메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하기 때문에 단 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다.
위 코드는 Circle 생성자 함수가 인스턴스를 생성할 때마다 getArea메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.

![Desktop](/assets/img/deepdive/deepdive19-01.png){: width:"600" height:"300"}

**이 처럼 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다.**

```js
// 생성자 함수
function Circle(radius){
  this.radius = radius; 
}

Circle.prototype.getArea = function(){
  return Math.PI * this.radius ** 2;
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);
```
위 처럼 프로토타입을 사용하여 상속을 구현하면 불필요한 중복을 제거할 수 있다.

![Desktop](/assets/img/deepdive/deepdive19-02.png){: width:"600" height:"300"}

`prototype` 프로퍼티는 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다.
따라서 생성자 함수로서 호출할 수 없는 `non-contructor`인 화살표 함수와 ES6 메서드 축양 표현으로 정의한 메서드는 `prototype` 프로퍼티를 소유할 수 없다.

## **프로토타입 객체**

프로토타입 객체란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다.
프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공한다.
프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용한다.

```js
function Person(name){
  this.name = name;
}

const person = { name : 'Lee'}
```
모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다.
[[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다.


내부 슬롯은 일반적으로 접근할 수 있지만 [[Prototype]]의 경우 `__proto__` 접근자 프로퍼티를 이용하여 간접적으로 접근할 수 있다.

![Desktop](/assets/img/deepdive/deepdive19-03.png){: width:"600" height:"300"}

```js
const person = { name : 'Lee'}

console.log(person.hasOwnProperty('__proto__')); // false
console.log(Object.getOwnPropertyDescriptor(Object.prototype,'__proto__'))
// {get: f, set: f, enumberable: false, configurable : true }
```
`__proto__` 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 `Object.prototype`의 프로퍼티다.
`__proto__` 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유는 상호 참조에 의해 프로터타입 체인이 생성되는 것을 방지하기 위해서다.

모든 프로토타입은 consturctor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.

**프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다**

```js
const parent = {};
const child = {};

child.__proto__ = parent;
parent.__proto__ = child; // TypeError: Cyclic __proto__ value
```

`__proto__`를 사용하여 프로토타입 참조를 취득하기 보다는 `Object.getPrototypeOf` 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 `Object.setPrototypeOf`를 사용하는 것이 좋다.



